<!DOCTYPE html>
<html lang="fr">
  
<!-- Mirrored from upload-helper.n0flow.io/ by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Feb 2026 10:08:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <base href="/lacale-helper-v2/">
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>La Cale - Upload Helper</title>
    <script>
      (() => {
        document.addEventListener(
          'click',
          (event) => {
            const anchor = event.target.closest('a[href="/"]');
            if (!anchor) return;

            event.preventDefault();
            const baseValue = document.querySelector('base')?.getAttribute('href') || './';
            window.location.assign(new URL('./', baseValue).toString());
          },
          true
        );
      })();
    </script>
    <style>
      .api-panel {
        margin: 16px;
        padding: 16px;
        border: 1px solid #334155;
        border-radius: 12px;
        background: #0f172a;
        color: #e2e8f0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      .api-drop {
        margin-top: 8px;
        border: 1px dashed #475569;
        border-radius: 10px;
        padding: 14px;
        cursor: pointer;
      }
      .api-result {
        margin-top: 12px;
        white-space: pre-wrap;
        max-height: 280px;
        overflow: auto;
        background: #020617;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 10px;
        font-size: 12px;
      }
      .api-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .api-btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid #334155;
        background: #111827;
        color: #e2e8f0;
        cursor: pointer;
      }
      .api-status { margin-top: 8px; font-size: 13px; color: #93c5fd; }
    </style>
    <script src="vendor/mediainfo-fichegen/MediaInfoWasm.js"></script>
    <script>
      (() => {
        const __LC_WASM_MODE_SIGNATURE = 'LC_MEDIAINFO_WASM_MODE_V5';
        const __LC_WASM_MODE_COMMIT = 'deploy-check-v5';
        const ALLOWED = ['.mkv', '.mp4', '.avi'];
        const MEDIAINFO_CDN_ESM_URL = 'https://cdn.jsdelivr.net/npm/mediainfo.js@0.3.6/dist/esm-bundle/index.min.js';
        const MEDIAINFO_CDN_WASM_URL = 'https://cdn.jsdelivr.net/npm/mediainfo.js@0.3.6/dist/MediaInfoModule.wasm';
        const DEBUG = localStorage.getItem('LC_DEBUG_WASM') === '1';

        let wasmModeEnabled = false;
        let mediaInfoAnalyzer = null;
        let fallbackUi = null;
        let analyzingOverlay = null;

        function sleep(ms){ return new Promise((r) => setTimeout(r, ms)); }


        function dbg(...args) {
          if (!DEBUG) return;
          console.log('[LC_WASM]', ...args);
        }


        async function waitFor(fn, timeout = 4000, step = 50) {
          const t0 = performance.now();
          while (performance.now() - t0 < timeout) {
            const value = fn();
            if (value) return value;
            await sleep(step);
          }
          return null;
        }

        function stopEventCompletely(e) {
          if (!e) return;
          if (typeof e.preventDefault === 'function') e.preventDefault();
          if (typeof e.stopPropagation === 'function') e.stopPropagation();
          if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
        }

        function isVisible(el) {
          if (!el) return false;
          const rect = el.getBoundingClientRect();
          return rect.width > 0 && rect.height > 0 && getComputedStyle(el).visibility !== 'hidden';
        }

        function findClickableByText(rx, root = document) {
          const nodes = [...root.querySelectorAll('button,a,[role="button"]')];
          return nodes.find((n) => isVisible(n) && rx.test((n.textContent || '').trim()));
        }

        function setNativeValue(el, value) {
          if ('value' in el) {
            const proto = Object.getPrototypeOf(el);
            const desc = Object.getOwnPropertyDescriptor(proto, 'value');
            if (desc && typeof desc.set === 'function') desc.set.call(el, value);
            else el.value = value;
          } else {
            el.textContent = value;
          }
          el.dispatchEvent(new Event('input', { bubbles: true }));
          el.dispatchEvent(new Event('change', { bubbles: true }));
          return true;
        }

        function ext(name) {
          const i = name.lastIndexOf('.');
          return i >= 0 ? name.slice(i).toLowerCase() : '';
        }

        function ensureOverlay() {
          if (analyzingOverlay) return analyzingOverlay;
          const el = document.createElement('div');
          el.setAttribute('data-lc-wasm-overlay', 'true');
          el.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(2,6,23,.65);z-index:9999;color:#e2e8f0;font:600 16px Inter,system-ui,sans-serif;padding:24px;text-align:center;';
          el.textContent = 'Analyse en cours…';
          document.body.appendChild(el);
          analyzingOverlay = el;
          return el;
        }

        function setOverlayVisible(visible, text = 'Analyse en cours…') {
          const overlay = ensureOverlay();
          overlay.textContent = text;
          overlay.style.display = visible ? 'flex' : 'none';
        }

        function setStatus(msg) {
          if (fallbackUi) fallbackUi.status.textContent = msg;
        }

        function ensureFallbackPanel() {
          if (fallbackUi) return fallbackUi;
          const appRoot = document.getElementById('app');
          if (!appRoot) return null;

          const root = document.createElement('section');
          root.className = 'api-panel';
          root.style.display = 'none';
          root.innerHTML = `
            <h3 style="margin:0 0 8px 0;">Fallback MediaInfo WASM</h3>
            <p style="margin:0 0 10px 0;color:#94a3b8;">Affiché uniquement si l'injection native “Coller un NFO” échoue.</p>
            <div class="api-row"><button id="api-copy-nfo" class="api-btn" type="button">Copier NFO</button></div>
            <div id="api-status" class="api-status"></div>
            <details style="margin-top:10px;"><summary>MediaInfo JSON</summary><pre id="api-json" class="api-result"></pre></details>
            <details style="margin-top:10px;" open><summary>NFO généré</summary><pre id="api-nfo" class="api-result"></pre></details>
          `;
          appRoot.insertAdjacentElement('afterend', root);

          fallbackUi = {
            root,
            status: root.querySelector('#api-status'),
            json: root.querySelector('#api-json'),
            nfo: root.querySelector('#api-nfo'),
            copyBtn: root.querySelector('#api-copy-nfo'),
          };
          fallbackUi.copyBtn.addEventListener('click', async () => {
            if (!fallbackUi.nfo.textContent) return;
            try {
              await navigator.clipboard.writeText(fallbackUi.nfo.textContent);
              setStatus('NFO copié dans le presse-papiers.');
            } catch {
              setStatus('Impossible de copier automatiquement.');
            }
          });
          return fallbackUi;
        }

        function showFallbackPanel(mediaInfoObject, nfoText, reason) {
          const ui = ensureFallbackPanel();
          if (!ui) return;
          ui.root.style.display = 'block';
          ui.json.textContent = JSON.stringify(mediaInfoObject || {}, null, 2);
          ui.nfo.textContent = nfoText || '';
          setStatus(`Fallback activé: ${reason}`);
        }

        function hideFallbackPanel() {
          const ui = ensureFallbackPanel();
          if (!ui) return;
          ui.root.style.display = 'none';
        }


        function ensureVersionBadge() {
          const existing = document.querySelector('[data-lc-wasm-badge="true"]');
          if (existing) return existing;
          const badge = document.createElement('div');
          badge.setAttribute('data-lc-wasm-badge', 'true');
          badge.textContent = 'WASM V5';
          badge.title = `${__LC_WASM_MODE_SIGNATURE} @ ${__LC_WASM_MODE_COMMIT}`;
          badge.style.cssText = 'position:fixed;right:10px;bottom:10px;z-index:10000;padding:4px 8px;border-radius:999px;background:rgba(15,23,42,.78);color:#cbd5e1;border:1px solid #334155;font:600 11px Inter,system-ui,sans-serif;pointer-events:none;';
          document.body.appendChild(badge);
          return badge;
        }

        function hideMediaInfoWarnings() {
          const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
          const badNodes = [];
          while (walker.nextNode()) {
            const value = String(walker.currentNode.nodeValue || '').toLowerCase();
            if (value.includes('module mediainfo') || value.includes('mediainfo indisponible')) {
              badNodes.push(walker.currentNode.parentElement);
            }
          }
          badNodes.forEach((el) => { if (el) el.style.display = 'none'; });
        }

        function normalizeValue(value) {
          if (value === null || value === undefined) return '';
          if (typeof value === 'boolean') return value ? 'Yes' : 'No';
          if (Array.isArray(value)) return value.map((v) => normalizeValue(v)).filter(Boolean).join(' / ');
          const str = String(value).trim();
          if (!str) return '';
          if (/^(true|yes)$/i.test(str)) return 'Yes';
          if (/^(false|no)$/i.test(str)) return 'No';
          return str;
        }

        function pick(track, candidates) {
          if (!track) return { key: null, value: '' };
          for (const key of candidates) {
            if (!(key in track)) continue;
            const value = normalizeValue(track[key]);
            if (value) return { key, value };
          }
          return { key: null, value: '' };
        }

        function renderMediaInfoText(tracks) {
          const PADDING = 41;
          const formatLine = (key, value) => `${key.padEnd(PADDING, ' ')} : ${value}`;
          const isInternalKey = (key) => key.startsWith('@') || key === 'extra';

          const sectionDefs = [
            {
              type: 'General',
              header: () => 'General',
              fields: [
                ['Unique ID', ['UniqueID', 'Unique_ID']],
                ['Format', ['Format']],
                ['Format version', ['Format_Version', 'FormatVersion']],
                ['File size', ['FileSize_String4', 'FileSize_String3', 'FileSize_String2', 'FileSize_String', 'FileSize']],
                ['Duration', ['Duration_String4', 'Duration_String3', 'Duration_String', 'Duration']],
                ['Overall bit rate', ['OverallBitRate_String', 'OverallBitRate']],
                ['Frame rate', ['FrameRate_String', 'FrameRate']],
                ['Title', ['Title']],
                ['Encoded date', ['Encoded_Date', 'EncodedDate']],
                ['Writing application', ['Encoded_Application', 'Writing_Application']],
                ['Writing library', ['Encoded_Library', 'Writing_Library']],
              ],
            },
            {
              type: 'Video',
              header: () => 'Video',
              fields: [
                ['ID', ['ID']],
                ['Format', ['Format']],
                ['Format/Info', ['Format_Info']],
                ['Format profile', ['Format_Profile']],
                ['HDR format', ['HDR_Format']],
                ['Codec ID', ['CodecID', 'Codec_ID']],
                ['Codec ID/Info', ['CodecID_Info', 'Codec_ID_Info']],
                ['Duration', ['Duration_String4', 'Duration_String3', 'Duration_String', 'Duration']],
                ['Bit rate', ['BitRate_String', 'BitRate']],
                ['Width', ['Width_String', 'Width']],
                ['Height', ['Height_String', 'Height']],
                ['Display aspect ratio', ['DisplayAspectRatio_String', 'DisplayAspectRatio']],
                ['Frame rate mode', ['FrameRate_Mode', 'FrameRateMode']],
                ['Frame rate', ['FrameRate_String', 'FrameRate']],
                ['Color space', ['ColorSpace']],
                ['Chroma subsampling', ['ChromaSubsampling_String', 'ChromaSubsampling']],
                ['Bit depth', ['BitDepth_String', 'BitDepth']],
                ['Bits/(Pixel*Frame)', ['Bits__Pixel_Frame_', 'Bits-(Pixel*Frame)', 'Bits_Pixel_Frame']],
                ['Stream size', ['StreamSize_String4', 'StreamSize_String3', 'StreamSize_String', 'StreamSize']],
                ['Default', ['Default']],
                ['Forced', ['Forced']],
                ['Color range', ['colour_range', 'ColorRange']],
                ['Color primaries', ['colour_primaries', 'ColorPrimaries']],
                ['Transfer characteristics', ['transfer_characteristics', 'TransferCharacteristics']],
                ['Matrix coefficients', ['matrix_coefficients', 'MatrixCoefficients']],
                ['Mastering display color primaries', ['MasteringDisplay_ColorPrimaries', 'MasteringDisplayColorPrimaries']],
                ['Mastering display luminance', ['MasteringDisplay_Luminance', 'MasteringDisplayLuminance']],
              ],
            },
            {
              type: 'Audio',
              header: (_, i) => `Audio #${i + 1}`,
              fields: [
                ['ID', ['ID']],
                ['Format', ['Format']],
                ['Format/Info', ['Format_Info']],
                ['Commercial name', ['Format_Commercial_IfAny', 'Format_Commercial']],
                ['Codec ID', ['CodecID', 'Codec_ID']],
                ['Codec ID/Info', ['CodecID_Info', 'Codec_ID_Info']],
                ['Duration', ['Duration_String4', 'Duration_String3', 'Duration_String', 'Duration']],
                ['Bit rate mode', ['BitRate_Mode', 'BitRateMode']],
                ['Bit rate', ['BitRate_String', 'BitRate']],
                ['Channel(s)', ['Channel_s_', 'Channels']],
                ['Channel layout', ['ChannelLayout', 'ChannelLayout_Original']],
                ['Sampling rate', ['SamplingRate_String', 'SamplingRate']],
                ['Frame rate', ['FrameRate_String', 'FrameRate']],
                ['Compression mode', ['Compression_Mode', 'CompressionMode']],
                ['Stream size', ['StreamSize_String4', 'StreamSize_String3', 'StreamSize_String', 'StreamSize']],
                ['Title', ['Title']],
                ['Language', ['Language_String3', 'Language']],
                ['Service kind', ['ServiceKind']],
                ['Default', ['Default']],
                ['Forced', ['Forced']],
              ],
            },
            {
              type: 'Text',
              header: (_, i) => `Text #${i + 1}`,
              fields: [
                ['ID', ['ID']],
                ['Format', ['Format']],
                ['Muxing mode', ['MuxingMode']],
                ['Codec ID', ['CodecID', 'Codec_ID']],
                ['Codec ID/Info', ['CodecID_Info', 'Codec_ID_Info']],
                ['Duration', ['Duration_String4', 'Duration_String3', 'Duration_String', 'Duration']],
                ['Bit rate', ['BitRate_String', 'BitRate']],
                ['Frame rate', ['FrameRate_String', 'FrameRate']],
                ['Count of elements', ['CountOfElements', 'Count_of_elements']],
                ['Stream size', ['StreamSize_String4', 'StreamSize_String3', 'StreamSize_String', 'StreamSize']],
                ['Title', ['Title']],
                ['Language', ['Language_String3', 'Language']],
                ['Default', ['Default']],
                ['Forced', ['Forced']],
              ],
            },
          ];

          const list = Array.isArray(tracks) ? tracks : [];
          const sections = [];

          for (const def of sectionDefs) {
            const matchingTracks = list.filter((track) => String(track?.['@type'] || '').toLowerCase() === def.type.toLowerCase());
            matchingTracks.forEach((track, index) => {
              const lines = [def.header(track, index)];
              const used = new Set();

              def.fields.forEach(([label, candidates]) => {
                const selected = pick(track, candidates);
                if (!selected.key || !selected.value) return;
                lines.push(formatLine(label, selected.value));
                used.add(selected.key);
              });

              Object.keys(track || {}).forEach((key) => {
                if (isInternalKey(key) || used.has(key)) return;
                const value = normalizeValue(track[key]);
                if (!value) return;
                const label = key.replace(/_/g, ' ');
                lines.push(formatLine(label, value));
              });

              if (lines.length > 1) sections.push(lines.join('\n'));
            });
          }

          const menuTrack = list.find((track) => String(track?.['@type'] || '').toLowerCase() === 'menu');
          if (menuTrack) {
            const menuLines = ['Menu'];
            Object.keys(menuTrack).forEach((key) => {
              if (isInternalKey(key)) return;
              if (!/^\d{2}:\d{2}:\d{2}\.?\d*$/.test(key)) return;
              const value = normalizeValue(menuTrack[key]);
              if (!value) return;
              menuLines.push(formatLine(key, value));
            });
            if (menuLines.length > 1) sections.push(menuLines.join('\n'));
          }

          return sections.join('\n\n').trim() + '\n';
        }

        async function getChunk(file, offset, length) {
          const chunk = file.slice(offset, offset + length);
          const buffer = await chunk.arrayBuffer();
          return new Uint8Array(buffer);
        }

        async function createAnalyzer() {
          if (mediaInfoAnalyzer) return mediaInfoAnalyzer;

          let lastError = null;

          // Priority: fichegen-style self-contained loader script + relative WASM.
          if (window.LCFichegenMediaInfo && typeof window.LCFichegenMediaInfo.create === 'function') {
            try {
              mediaInfoAnalyzer = await window.LCFichegenMediaInfo.create();
              return mediaInfoAnalyzer;
            } catch (error) {
              lastError = new Error(`[fichegen-loader] ${error.message || error}`);
            }
          }

          // Secondary fallback: direct ESM + CDN WASM.
          try {
            const module = await import(MEDIAINFO_CDN_ESM_URL);
            const MediaInfoFactory = module.default || module;
            mediaInfoAnalyzer = await MediaInfoFactory({
              format: 'object',
              locateFile: () => MEDIAINFO_CDN_WASM_URL,
            });
            return mediaInfoAnalyzer;
          } catch (error) {
            lastError = new Error(`[cdn-fallback] ${error.message || error}`);
          }

          throw lastError || new Error('Impossible de charger mediainfo.js');
        }

        async function analyzeWithWasm(file) {
          const analyzer = await createAnalyzer();
          try {
            return await analyzer.analyzeData(
              () => file.size,
              (size, offset) => getChunk(file, offset, size)
            );
          } finally {
            if (analyzer && typeof analyzer.close === 'function') {
              analyzer.close();
              mediaInfoAnalyzer = null;
            }
          }
        }

        function humanFileSize(bytes) {
          if (!Number.isFinite(bytes) || bytes <= 0) return '';
          const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB'];
          let value = bytes;
          let i = 0;
          while (value >= 1024 && i < units.length - 1) {
            value /= 1024;
            i += 1;
          }
          const decimals = value >= 100 || i === 0 ? 0 : 1;
          return `${value.toFixed(decimals)} ${units[i]}`;
        }

        function normalizeReleaseName(input) {
          return String(input || '').replace(/\.[^.]+$/, '').replace(/[._]+/g, ' ').trim();
        }

        function detectReleaseGroup(fileName, generalTitle) {
          const haystacks = [fileName, generalTitle].filter(Boolean).map((s) => String(s));
          for (const text of haystacks) {
            const bracket = text.match(/\[([A-Za-z0-9._-]{2,})\](?:\s*$|\s)/);
            if (bracket) return bracket[1];
            const codecGroup = text.match(/(?:x264|x265|hevc|h264|h265)[^\w-]*-([A-Za-z0-9._-]{2,})/i);
            if (codecGroup) return codecGroup[1];
            const tail = text.match(/-([A-Za-z0-9._-]{2,})\s*$/);
            if (tail) return tail[1];
          }
          return '';
        }

        function computeTitleCandidate(fileName, generalTitle) {
          const raw = (generalTitle && String(generalTitle).trim()) || normalizeReleaseName(fileName);
          let cleaned = raw
            .replace(/\b(2160p|1080p|720p|4k|uhd)\b/ig, ' ')
            .replace(/\b(x264|x265|h264|h265|hevc|avc)\b/ig, ' ')
            .replace(/\b(hdr10\+?|hdr|dv|dolby\s*vision)\b/ig, ' ')
            .replace(/\b(bluray|blu-ray|brrip|bdrip|webrip|web-dl|hdtv|remux|dvdrip)\b/ig, ' ')
            .replace(/\b(ddp|ac3|eac3|dts(?:-hd)?|atmos|truehd|aac)\b/ig, ' ')
            .replace(/\b(multi|vostfr|truefrench|french|eng|fr)\b/ig, ' ')
            .replace(/-[A-Za-z0-9._-]{2,}\s*$/g, ' ')
            .replace(/[._]+/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
          if (!cleaned) cleaned = normalizeReleaseName(fileName);
          return cleaned;
        }

        function findFieldBySemantic(regex) {
          const labels = [...document.querySelectorAll('label,div,span,p')]
            .filter((el) => isVisible(el) && regex.test((el.textContent || '').toLowerCase()));
          for (const label of labels) {
            const htmlFor = label.getAttribute && label.getAttribute('for');
            if (htmlFor) {
              const direct = document.getElementById(htmlFor);
              if (direct && isVisible(direct)) return direct;
            }
            const near = label.closest('div,section,form,fieldset') || document;
            const field = near.querySelector('input:not([type="file"]),textarea');
            if (field && isVisible(field) && !field.disabled) return field;
          }
          const byPlaceholder = [...document.querySelectorAll('input:not([type="file"]),textarea')]
            .find((el) => isVisible(el) && regex.test((el.placeholder || '').toLowerCase()) && !el.disabled);
          return byPlaceholder || null;
        }

        function fillFieldIfFound(regex, value, tag) {
          if (!value) return false;
          const field = findFieldBySemantic(regex);
          if (!field) {
            dbg('field-not-found', tag);
            return false;
          }
          setNativeValue(field, value);
          dbg('field-filled', tag, value);
          return true;
        }

        function extractGeneralTrack(mediaInfoObject) {
          const tracks = mediaInfoObject?.media?.track || [];
          return tracks.find((t) => String(t?.['@type'] || '').toLowerCase() === 'general') || {};
        }

        async function injectNfoNativeV7(nfoText) {
          dbg('inject-start');
          const open = findClickableByText(/coller\s+un\s+nfo/i);
          if (!open) return { ok: false, why: "bouton 'Coller un NFO' introuvable" };
          open.click();
          dbg('inject-open-clicked');

          const modal = await waitFor(
            () => [...document.querySelectorAll('[role="dialog"],.modal,[data-modal],form')].find((el) => isVisible(el)) || null,
            4000
          );
          if (!modal) return { ok: false, why: 'dialog Coller un NFO introuvable' };

          const targetField = await waitFor(() => {
            const fields = [...modal.querySelectorAll('textarea,[contenteditable="true"],input[type="text"]')]
              .filter((el) => isVisible(el) && !el.disabled);
            return fields[0] || null;
          }, 4000);
          if (!targetField) return { ok: false, why: 'textarea NFO introuvable' };

          setNativeValue(targetField, nfoText);
          dbg('inject-textarea-filled');

          let validationTriggered = false;
          const modalForm = targetField.closest('form') || modal.querySelector('form');
          if (modalForm) {
            if (typeof modalForm.requestSubmit === 'function') modalForm.requestSubmit();
            else modalForm.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
            validationTriggered = true;
            dbg('inject-form-submitted');
          } else {
            const submitBtn = [...modal.querySelectorAll('button,input[type="submit"]')].find((el) => isVisible(el) && !el.disabled && (el.type === 'submit' || el.getAttribute('type') === 'submit'));
            const textBtn =
              submitBtn ||
              findClickableByText(/valider|importer|analyser|continuer|g[ée]n[ée]rer/i, modal);
            if (!textBtn) return { ok: false, why: 'bouton de validation introuvable' };
            textBtn.click();
            validationTriggered = true;
            dbg('inject-validate-clicked');
          }

          if (!validationTriggered) return { ok: false, why: 'validation non déclenchée' };

          await waitFor(() => !isVisible(modal) || !!findTmdbNode(), 2500);
          return { ok: true, validated: true };
        }

        function findTmdbNode() {
          const nodes = [...document.querySelectorAll('h1,h2,h3,div,span,label,p,input,button')];
          return nodes.find((n) => {
            const txt = (n.textContent || n.getAttribute?.('placeholder') || '').toLowerCase();
            return txt.includes('recherche tmdb') || txt.includes('sélectionnez le film') || txt.includes('selectionnez le film') || txt.includes('tmdb');
          }) || null;
        }

        function forceGoTmdb() {
          const candidate = findClickableByText(/suivant|continuer|tmdb|rechercher/i);
          if (candidate) {
            candidate.click();
            dbg('force-go-tmdb-click');
            return true;
          }
          return false;
        }

        async function prefillTmdbTitle(titleCandidate) {
          if (!titleCandidate) return false;
          const input = await waitFor(() => {
            const byLabel = findFieldBySemantic(/tmdb|recherche|titre/);
            if (byLabel && isVisible(byLabel)) return byLabel;
            const visibleInput = [...document.querySelectorAll('input[type="text"],input:not([type]),input[type="search"]')]
              .find((el) => isVisible(el) && !el.disabled);
            return visibleInput || null;
          }, 2500);
          if (!input) return false;
          setNativeValue(input, titleCandidate);
          dbg('tmdb-prefilled', titleCandidate);
          return true;
        }

        async function detectAndScrollTmdb(titleCandidate) {
          let tmdbNode = await waitFor(() => findTmdbNode(), 3500);
          if (!tmdbNode) {
            forceGoTmdb();
            tmdbNode = await waitFor(() => findTmdbNode(), 2500);
          }

          if (tmdbNode && tmdbNode.scrollIntoView) {
            tmdbNode.scrollIntoView({ behavior: 'smooth', block: 'start' });
            if (typeof tmdbNode.focus === 'function') tmdbNode.focus({ preventScroll: true });
          }

          await prefillTmdbTitle(titleCandidate);
          return !!tmdbNode;
        }

        async function handleFileExclusive(file, event, origin = 'exclusive') {
          if (!wasmModeEnabled) return;
          stopEventCompletely(event);
          if (!file) return;
          const extension = ext(file.name || '');
          if (!ALLOWED.includes(extension)) return;

          setOverlayVisible(true, 'Analyse en cours…');
          hideMediaInfoWarnings();

          try {
            const mediaInfoObject = await analyzeWithWasm(file);
            const tracks = mediaInfoObject?.media?.track || [];
            const generalTrack = extractGeneralTrack(mediaInfoObject);
            const nfoText = renderMediaInfoText(tracks);
            const sizeHuman = humanFileSize(file.size);
            const sourceDetected = detectReleaseGroup(file.name || '', generalTrack.Title || generalTrack.Movie || '');
            const titleCandidate = computeTitleCandidate(file.name || '', generalTrack.Title || generalTrack.Movie || '');
            dbg('metadata', { sizeHuman, sourceDetected, titleCandidate, origin });

            fillFieldIfFound(/taille|file size|size/i, sizeHuman, 'size');
            fillFieldIfFound(/source|team|release/i, sourceDetected, 'source');

            setOverlayVisible(false);

            const injected = await injectNfoNativeV7(nfoText);
            if (!injected.ok) {
              showFallbackPanel(mediaInfoObject, nfoText, injected.why);
              return;
            }

            hideFallbackPanel();
            setStatus(`${__LC_WASM_MODE_SIGNATURE}: analyse OK (${origin}), validation native déclenchée.`);
            await detectAndScrollTmdb(titleCandidate); // best effort, non bloquant
            hideMediaInfoWarnings();
          } catch (err) {
            showFallbackPanel({}, '', `erreur WASM: ${err.message || err}`);
          } finally {
            setOverlayVisible(false);
          }
        }

        function setupCaptureInterceptors() {
          const looksLikeVideoFile = (file) => !!file && ALLOWED.includes(ext(file.name || ''));

          document.addEventListener('change', (event) => {
            if (!wasmModeEnabled) return;
            const input = event.target;
            if (!(input instanceof HTMLInputElement) || input.type !== 'file') return;
            const file = input.files && input.files[0];
            if (!looksLikeVideoFile(file)) return;
            handleFileExclusive(file, event, 'input-capture');
          }, true);

          document.addEventListener('drop', (event) => {
            if (!wasmModeEnabled) return;
            const file = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0];
            if (!looksLikeVideoFile(file)) return;
            handleFileExclusive(file, event, 'drop-capture');
          }, true);

          document.addEventListener('dragover', (event) => {
            if (!wasmModeEnabled) return;
            const dt = event.dataTransfer;
            if (!dt || !dt.files || !dt.files[0] || !looksLikeVideoFile(dt.files[0])) return;
            stopEventCompletely(event);
          }, true);
        }

        window.addEventListener('unhandledrejection', (event) => {
          if (!wasmModeEnabled) return;
          const reasonText = String(event.reason && (event.reason.message || event.reason) || '').toLowerCase();
          if (reasonText.includes('mediainfo')) {
            event.preventDefault();
            hideMediaInfoWarnings();
          }
        });

        document.addEventListener('DOMContentLoaded', async () => {
          console.log(__LC_WASM_MODE_SIGNATURE, 'commit', __LC_WASM_MODE_COMMIT);
          ensureVersionBadge();
          ensureFallbackPanel();
          ensureOverlay();

          try {
            await createAnalyzer();
            wasmModeEnabled = true;
            setStatus(`${__LC_WASM_MODE_SIGNATURE}: actif.`);
          } catch (error) {
            wasmModeEnabled = false;
            showFallbackPanel({}, '', `chargement MediaInfo impossible: ${error.message || error}`);
          }

          setupCaptureInterceptors();

          const observer = new MutationObserver(() => {
            if (wasmModeEnabled) hideMediaInfoWarnings();
          });
          observer.observe(document.body, { subtree: true, childList: true, characterData: true });
        });
      })();
    </script>
    <script type="module" crossorigin src="assets/index-Ddv4Ao2m.js"></script>
    <link rel="stylesheet" crossorigin href="assets/index-BXI7GdG3.css">
  </head>
  <body>
    <div id="app"></div>
  </body>

<!-- Mirrored from upload-helper.n0flow.io/ by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Feb 2026 10:08:26 GMT -->
</html>
