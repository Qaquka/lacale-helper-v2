<!DOCTYPE html>
<html lang="fr">
  
<!-- Mirrored from upload-helper.n0flow.io/ by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Feb 2026 10:08:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <base href="/lacale-helper-v2/">
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>La Cale - Upload Helper</title>
    <script>
      (() => {
        document.addEventListener(
          'click',
          (event) => {
            const anchor = event.target.closest('a[href="/"]');
            if (!anchor) return;

            event.preventDefault();
            const baseValue = document.querySelector('base')?.getAttribute('href') || './';
            window.location.assign(new URL('./', baseValue).toString());
          },
          true
        );
      })();
    </script>
    <style>
      .api-panel {
        margin: 16px;
        padding: 16px;
        border: 1px solid #334155;
        border-radius: 12px;
        background: #0f172a;
        color: #e2e8f0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      .api-drop {
        margin-top: 8px;
        border: 1px dashed #475569;
        border-radius: 10px;
        padding: 14px;
        cursor: pointer;
      }
      .api-result {
        margin-top: 12px;
        white-space: pre-wrap;
        max-height: 280px;
        overflow: auto;
        background: #020617;
        border: 1px solid #1e293b;
        border-radius: 8px;
        padding: 10px;
        font-size: 12px;
      }
      .api-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .api-btn {
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid #334155;
        background: #111827;
        color: #e2e8f0;
        cursor: pointer;
      }
      .api-status { margin-top: 8px; font-size: 13px; color: #93c5fd; }
    </style>
    <script>
      (() => {
        const __LC_WASM_MODE_SIGNATURE = 'LC_MEDIAINFO_WASM_MODE_V2';
        const ALLOWED = ['.mkv', '.mp4', '.avi'];
        const MEDIAINFO_LOCAL_ESM_URL = new URL('vendor/mediainfo/index.min.js', document.baseURI).toString();
        const MEDIAINFO_LOCAL_WASM_URL = new URL('vendor/mediainfo/MediaInfoModule.wasm', document.baseURI).toString();
        const MEDIAINFO_CDN_ESM_URL = 'https://cdn.jsdelivr.net/npm/mediainfo.js@0.3.6/dist/esm-bundle/index.min.js';
        const MEDIAINFO_CDN_WASM_URL = 'https://cdn.jsdelivr.net/npm/mediainfo.js@0.3.6/dist/MediaInfoModule.wasm';

        let wasmModeEnabled = false;
        let mediaInfoAnalyzer = null;
        let fallbackUi = null;

        function sleep(ms) { return new Promise((resolve) => setTimeout(resolve, ms)); }

        function waitFor(fn, timeout = 4000, step = 50) {
          return new Promise((resolve) => {
            const t0 = performance.now();
            const tick = () => {
              const value = fn();
              if (value) return resolve(value);
              if (performance.now() - t0 >= timeout) return resolve(null);
              setTimeout(tick, step);
            };
            tick();
          });
        }

        function isVisible(el) {
          if (!el) return false;
          const rect = el.getBoundingClientRect();
          return rect.width > 0 && rect.height > 0 && getComputedStyle(el).visibility !== 'hidden';
        }

        function findClickableByText(rx, root = document) {
          const nodes = [...root.querySelectorAll('button,a,[role="button"]')];
          return nodes.find((n) => isVisible(n) && rx.test((n.textContent || '').trim()));
        }

        function setNativeValue(el, value) {
          if ('value' in el) {
            const proto = Object.getPrototypeOf(el);
            const desc = Object.getOwnPropertyDescriptor(proto, 'value');
            if (desc && typeof desc.set === 'function') {
              desc.set.call(el, value);
            } else {
              el.value = value;
            }
          } else {
            el.textContent = value;
          }
          el.dispatchEvent(new Event('input', { bubbles: true }));
          el.dispatchEvent(new Event('change', { bubbles: true }));
          return true;
        }

        function ext(name) {
          const i = name.lastIndexOf('.');
          return i >= 0 ? name.slice(i).toLowerCase() : '';
        }

        function setStatus(msg) {
          if (!fallbackUi) return;
          fallbackUi.status.textContent = msg;
        }

        function ensureFallbackPanel() {
          if (fallbackUi) return fallbackUi;
          const appRoot = document.getElementById('app');
          if (!appRoot) return null;

          const root = document.createElement('section');
          root.className = 'api-panel';
          root.style.display = 'none';
          root.innerHTML = `
            <h3 style="margin:0 0 8px 0;">Fallback MediaInfo WASM</h3>
            <p style="margin:0 0 10px 0;color:#94a3b8;">Affiché uniquement si l'injection “Coller un NFO” échoue.</p>
            <div class="api-row">
              <button id="api-copy-nfo" class="api-btn" type="button">Copier NFO</button>
            </div>
            <div id="api-status" class="api-status"></div>
            <details style="margin-top:10px;">
              <summary>MediaInfo JSON</summary>
              <pre id="api-json" class="api-result"></pre>
            </details>
            <details style="margin-top:10px;" open>
              <summary>NFO généré</summary>
              <pre id="api-nfo" class="api-result"></pre>
            </details>
          `;
          appRoot.insertAdjacentElement('afterend', root);

          const ui = {
            root,
            status: root.querySelector('#api-status'),
            json: root.querySelector('#api-json'),
            nfo: root.querySelector('#api-nfo'),
            copyBtn: root.querySelector('#api-copy-nfo'),
          };
          ui.copyBtn.addEventListener('click', async () => {
            if (!ui.nfo.textContent) return;
            try {
              await navigator.clipboard.writeText(ui.nfo.textContent);
              setStatus('NFO copié dans le presse-papiers.');
            } catch {
              setStatus('Impossible de copier automatiquement.');
            }
          });

          fallbackUi = ui;
          return ui;
        }

        function showFallbackPanel(mediaInfoObject, nfoText, reason) {
          const ui = ensureFallbackPanel();
          if (!ui) return;
          ui.root.style.display = 'block';
          ui.json.textContent = JSON.stringify(mediaInfoObject || {}, null, 2);
          ui.nfo.textContent = nfoText || '';
          setStatus(`Fallback activé: ${reason}`);
        }

        function findNfoTargetField(root = document) {
          const fields = [...root.querySelectorAll('textarea,[contenteditable="true"],input[type="text"]')]
            .filter((el) => isVisible(el));
          return fields[0] || null;
        }

        async function injectNfoAndGoTmdb(nfoText) {
          const open = findClickableByText(/coller un nfo/i);
          if (!open) return { ok: false, why: "bouton 'Coller un NFO' introuvable" };
          open.click();

          const modal = await waitFor(
            () => document.querySelector('[role="dialog"],.modal,[data-modal]') || document.body,
            3000
          );
          const targetField = await waitFor(() => findNfoTargetField(modal), 3000);
          if (!targetField) return { ok: false, why: 'textarea NFO introuvable' };

          setNativeValue(targetField, nfoText);

          const validate =
            findClickableByText(/valider/i, modal) ||
            findClickableByText(/importer/i, modal) ||
            findClickableByText(/analyser/i, modal) ||
            findClickableByText(/continuer/i, modal) ||
            findClickableByText(/g[ée]n[ée]rer/i, modal);
          if (!validate) return { ok: false, why: 'bouton de validation introuvable' };
          validate.click();

          const tmdbNode = await waitFor(() => {
            const nodes = [...document.querySelectorAll('h1,h2,h3,div,span,label,p')];
            return nodes.find((n) => {
              const txt = (n.textContent || '').toLowerCase();
              return txt.includes('recherche tmdb') || txt.includes('sélectionnez le film') || txt.includes('selectionnez le film') || txt.includes('tmdb');
            }) || null;
          }, 4500);

          if (tmdbNode && tmdbNode.scrollIntoView) {
            tmdbNode.scrollIntoView({ behavior: 'smooth', block: 'start' });
            return { ok: true };
          }

          return { ok: false, why: 'écran TMDB non détecté après validation' };
        }

        function hideMediaInfoWarnings() {
          const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
          const badNodes = [];
          while (walker.nextNode()) {
            const value = String(walker.currentNode.nodeValue || '').toLowerCase();
            if (value.includes('module mediainfo') || value.includes('mediainfo indisponible')) {
              badNodes.push(walker.currentNode.parentElement);
            }
          }
          badNodes.forEach((el) => {
            if (el) el.style.display = 'none';
          });
        }

        function toNfoLikeText(parsed) {
          try {
            const tracks = parsed?.media?.track || [];
            const byType = (type) => tracks.find((t) => String(t['@type'] || '').toLowerCase() === type) || {};
            const g = byType('general');
            const v = byType('video');
            const a = byType('audio');
            return [
              'General',
              `Complete name                            : ${g.CompleteName || ''}`,
              `Format                                   : ${g.Format || ''}`,
              `File size                                : ${g.FileSize_String || g.FileSize || ''}`,
              `Duration                                 : ${g.Duration_String3 || g.Duration_String || g.Duration || ''}`,
              '',
              'Video',
              `Format                                   : ${v.Format || ''}`,
              `Width                                    : ${v.Width_String || v.Width || ''}`,
              `Height                                   : ${v.Height_String || v.Height || ''}`,
              `Frame rate                               : ${v.FrameRate_String || v.FrameRate || ''}`,
              `Bit rate                                 : ${v.BitRate_String || v.BitRate || ''}`,
              '',
              'Audio',
              `Format                                   : ${a.Format || ''}`,
              `Channels                                 : ${a.Channels || a['Channel(s)'] || ''}`,
              `Bit rate                                 : ${a.BitRate_String || a.BitRate || ''}`,
              `Language                                 : ${a.Language_String3 || a.Language || ''}`,
            ].join('
').trim() + '
';
          } catch {
            return '';
          }
        }

        async function getChunk(file, offset, length) {
          const chunk = file.slice(offset, offset + length);
          const buffer = await chunk.arrayBuffer();
          return new Uint8Array(buffer);
        }

        async function createAnalyzer() {
          if (mediaInfoAnalyzer) return mediaInfoAnalyzer;

          const attempts = [
            { esmUrl: MEDIAINFO_LOCAL_ESM_URL, wasmUrl: MEDIAINFO_LOCAL_WASM_URL, label: 'local-vendor' },
            { esmUrl: MEDIAINFO_CDN_ESM_URL, wasmUrl: MEDIAINFO_CDN_WASM_URL, label: 'cdn-fallback' },
          ];

          let lastError = null;
          for (const attempt of attempts) {
            try {
              const module = await import(attempt.esmUrl);
              const MediaInfoFactory = module.default || module;
              mediaInfoAnalyzer = await MediaInfoFactory({
                format: 'object',
                locateFile: () => attempt.wasmUrl,
              });
              return mediaInfoAnalyzer;
            } catch (error) {
              lastError = new Error(`[${attempt.label}] ${error.message || error}`);
            }
          }
          throw lastError || new Error('Impossible de charger mediainfo.js');
        }

        async function analyzeWithWasm(file) {
          const analyzer = await createAnalyzer();
          try {
            return await analyzer.analyzeData(
              () => file.size,
              (size, offset) => getChunk(file, offset, size)
            );
          } finally {
            if (analyzer && typeof analyzer.close === 'function') {
              analyzer.close();
              mediaInfoAnalyzer = null;
            }
          }
        }

        async function handleVideoFile(file, origin = 'manual') {
          if (!file) return;
          const extension = ext(file.name || '');
          if (!ALLOWED.includes(extension)) return;

          setStatus(`${__LC_WASM_MODE_SIGNATURE}: analyse en cours (${origin})…`);
          hideMediaInfoWarnings();

          try {
            const mediaInfoObject = await analyzeWithWasm(file);
            const nfoText = toNfoLikeText(mediaInfoObject);
            const injected = await injectNfoAndGoTmdb(nfoText);

            if (injected.ok) {
              hideMediaInfoWarnings();
              setStatus(`${__LC_WASM_MODE_SIGNATURE}: analyse OK, TMDB ouvert.`);
              return;
            }

            showFallbackPanel(mediaInfoObject, nfoText, injected.why);
          } catch (err) {
            showFallbackPanel({}, '', `erreur WASM: ${err.message || err}`);
          }
        }

        function setupCaptureInterceptors() {
          const looksLikeVideoFile = (file) => !!file && ALLOWED.includes(ext(file.name || ''));

          document.addEventListener('change', (event) => {
            if (!wasmModeEnabled) return;
            const input = event.target;
            if (!(input instanceof HTMLInputElement) || input.type !== 'file') return;
            const file = input.files && input.files[0];
            if (!looksLikeVideoFile(file)) return;
            event.preventDefault();
            event.stopImmediatePropagation();
            handleVideoFile(file, 'input-capture');
          }, true);

          ['drop', 'dragover', 'dragenter'].forEach((type) => {
            document.addEventListener(type, (event) => {
              if (!wasmModeEnabled) return;
              const dt = event.dataTransfer;
              if (!dt || !dt.files || !looksLikeVideoFile(dt.files[0])) return;
              event.preventDefault();
              if (type === 'drop') {
                event.stopImmediatePropagation();
                handleVideoFile(dt.files[0], 'drop-capture');
              }
            }, true);
          });
        }

        window.addEventListener('unhandledrejection', (event) => {
          if (!wasmModeEnabled) return;
          const reasonText = String(event.reason && (event.reason.message || event.reason) || '').toLowerCase();
          if (reasonText.includes('mediainfo')) {
            event.preventDefault();
            hideMediaInfoWarnings();
          }
        });

        document.addEventListener('DOMContentLoaded', async () => {
          ensureFallbackPanel();
          try {
            await createAnalyzer();
            wasmModeEnabled = true;
            setStatus(`${__LC_WASM_MODE_SIGNATURE}: actif.`);
          } catch (error) {
            wasmModeEnabled = false;
            showFallbackPanel({}, '', `chargement MediaInfo impossible: ${error.message || error}`);
          }

          setupCaptureInterceptors();

          const observer = new MutationObserver(() => {
            if (wasmModeEnabled) hideMediaInfoWarnings();
          });
          observer.observe(document.body, { subtree: true, childList: true, characterData: true });
        });
      })();
    </script>
    <script type="module" crossorigin src="assets/index-Ddv4Ao2m.js"></script>
    <link rel="stylesheet" crossorigin href="assets/index-BXI7GdG3.css">
  </head>
  <body>
    <div id="app"></div>
  </body>

<!-- Mirrored from upload-helper.n0flow.io/ by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 17 Feb 2026 10:08:26 GMT -->
</html>
